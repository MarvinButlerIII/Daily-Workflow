// I'll now code my ownn implementation of console.log(), which doesn't return the value of undefined.

function consoleLog(val) {
    console.log(val)
    return val
}

// I'm using the console.log() function inside my custom consoleLog function
//declaration and specifying to return value of its argument

//consoleLog('Hello') // 'Hello'
//I run my custom consoleLog() function and get the output 'Hello'
//so the value is ouput in the console, but it's also returned.

// Example code of a function that returns a double of a number that it recieved.

function doubleIt(num) {
    return num * 2
}


// Now i'll code another function that builds an object with a specific value

function objectMaker(val) {
    return {
        prop: val
    }
}

// I can call the objectMaker() function with any value like, such as

objectMaker(20);

// The returned value will be an object with a single prop key set to 20

{prop:20}

// Functions can also be assigned to a variable for later use or amipulation

doubleIt(10).toString()
//the above code returns the number 20 as a string that is "20"

// I can even combine my custom function calls as follows

objectMaker( doubleIt(100) );

// It will now return the following value

{prop: 200}

// Being able to return custom values is one of the foundations that make functional programming possible.
// This final code example summarizes the key learning points in this reading.

// Function to double a number 

function doubleIt(num) {
    return num * 2;
}

// Function to create an object with a 'prop' key

function objectMaker(val) {
    return {prop: val};
}

// Chaining funcitons and returning values
let result = objectMaker(doubleIt(5));
console.log(result); // { prop: 10 }

